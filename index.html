<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automatic Prediction System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .card {
            background-color: #ffffff;
            border-radius: 16px;
            box-shadow: 0 10px 35px rgba(0, 0, 0, 0.08), 0 2px 8px rgba(0,0,0,0.06);
        }
        .form-input {
            border: 2px solid #e2e8f0; border-radius: 8px; padding: 12px;
            font-size: 1rem; width: 100%; transition: border-color 0.3s ease;
        }
        .form-input:focus { outline: none; border-color: #4f46e5; }
        .btn {
            font-weight: 600; padding: 12px 20px; border-radius: 8px;
            transition: all 0.2s ease; border: 2px solid transparent; cursor: pointer;
        }
        .btn:disabled { background-color: #e5e7eb; color: #6b7280; cursor: not-allowed; }
        .btn-primary { background-color: #4f46e5; color: #ffffff; }
        .btn-primary:hover:not(:disabled) { background-color: #4338ca; transform: translateY(-1px); }
        .btn-secondary { background-color: #eef2ff; color: #4f46e5; }
        .btn-secondary:hover:not(:disabled) { background-color: #e0e7ff; }
        .btn-danger { background-color: #fee2e2; color: #dc2626; }
        .btn-danger:hover { background-color: #fecaca; }
        
        .history-list { max-height: 400px; overflow-y: auto; padding-right: 8px; }
        .history-item {
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
            padding: 12px;
            border-radius: 8px;
        }
        .history-item.is-success { background-color: #f0fdf4; border-color: #22c55e; }
        .history-item.is-fail { background-color: #fef2f2; border-color: #ef4444; }

        .swap-btn {
            height: 40px; width: 40px;
            background-color: #fff;
            border: 2px solid #e2e8f0;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s ease; color: #9ca3af;
        }
        .swap-btn:hover { color: #4f46e5; border-color: #c7d2fe; transform: rotate(180deg); }

        .result-display { border-radius: 12px; background-color: #f8fafc; padding: 16px; }
        .prediction-block {
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            margin-top: 8px;
        }
        .prediction-block.recommended {
            border-color: #4f46e5;
            background-color: #eef2ff;
        }
        .recommendation-badge {
            font-size: 0.75rem;
            font-weight: 700;
            padding: 2px 8px;
            border-radius: 9999px;
            color: #ffffff;
            background-color: #4f46e5;
            margin-left: 8px;
        }

        /* Toggle Switch styles */
        .toggle-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            width: 100%;
        }
        .toggle-checkbox {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
        }
        .toggle-switch {
            width: 52px;
            height: 32px;
            background-color: #e5e7eb;
            border-radius: 9999px;
            position: relative;
            transition: background-color 0.2s ease-in-out;
            flex-shrink: 0;
        }
        .toggle-knob {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 28px;
            height: 28px;
            background-color: white;
            border-radius: 9999px;
            transition: transform 0.2s ease-in-out;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .toggle-checkbox:checked + .toggle-switch {
            background-color: #4f46e5;
        }
        .toggle-checkbox:checked + .toggle-switch .toggle-knob {
            transform: translateX(20px);
        }
    </style>
</head>
<body class="text-gray-800 py-10 px-4">
    <div class="w-full max-w-4xl mx-auto grid grid-cols-1 lg:grid-cols-2 gap-8">
        <main class="space-y-8 lg:col-span-1">
            <div class="card p-8 space-y-6">
                <div class="text-center">
                    <h1 class="text-3xl font-bold text-gray-800">Automatic Prediction System</h1>
                    <p class="text-gray-500 text-sm mt-1">Select your desired prediction mode.</p>
                </div>

                <div class="p-4 bg-gray-50 rounded-lg">
                    <label class="toggle-label">
                        <div class="text-left">
                            <span class="font-bold text-gray-700">Use Guide Book Rules</span>
                            <p class="text-xs text-gray-500">On: Use simple rules. Off: Use advanced points system.</p>
                        </div>
                        <input type="checkbox" id="modeToggle" class="toggle-checkbox" checked>
                        <div class="toggle-switch"><div class="toggle-knob"></div></div>
                    </label>
                </div>

                <div class="flex items-center space-x-4">
                    <div class="flex-1 space-y-2">
                        <label for="number1" class="text-sm font-medium text-gray-700">Previous Number</label>
                        <input type="number" id="number1" class="form-input">
                    </div>
                    <button id="swapButton" class="swap-btn mt-8 flex-shrink-0" aria-label="Swap numbers">
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M7 16V4m0 12l-4-4m4 4l4-4m6 8v-12m0 12l-4-4m4 4l4-4" />
                        </svg>
                    </button>
                    <div class="flex-1 space-y-2">
                        <label for="number2" class="text-sm font-medium text-gray-700">Last Number</label>
                        <input type="number" id="number2" class="form-input">
                    </div>
                </div>
                
                <button id="calculateButton" class="w-full btn btn-primary">Calculate</button>
                
                <div id="resultDisplay" class="hidden"></div>
            </div>
        </main>
        
        <aside class="space-y-8 lg:col-span-1">
             <div class="card p-8 space-y-4" id="historySection">
                <div class="flex justify-between items-center">
                    <h2 class="text-xl font-bold text-gray-700">History</h2>
                    <button id="clearHistoryButton" class="btn btn-danger text-sm py-2 px-3">Clear</button>
                </div>
                <div class="text-sm font-medium">
                    <span id="winLossTracker">Wins: 0, Losses: 0, Rate: N/A</span>
                </div>
                <ul id="historyList" class="history-list space-y-3"></ul>
            </div>
        </aside>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            let history = [];
            let confirmedWinsLog = [];
            let useGuideBookRules = true; // Default to the new system

            let calculationState = {};
            let rulePerformance = {};

            const dom = {
                number1: document.getElementById('number1'),
                number2: document.getElementById('number2'),
                calculateButton: document.getElementById('calculateButton'),
                swapButton: document.getElementById('swapButton'),
                resultDisplay: document.getElementById('resultDisplay'),
                historyList: document.getElementById('historyList'),
                clearHistoryButton: document.getElementById('clearHistoryButton'),
                winLossTracker: document.getElementById('winLossTracker'),
                modeToggle: document.getElementById('modeToggle')
            };

            const recommendationRules = [
                { id: 'lowest_dist_highest_streak', label: 'Lowest Distance & Highest Streak' },
                { id: 'highest_dist_highest_streak', label: 'Highest Distance & Highest Streak' },
                { id: 'lowest_dist_only', label: 'Lowest Distance ONLY' },
                { id: 'highest_dist_only', label: 'Highest Distance ONLY' },
                { id: 'only_minus', label: 'Only (-)' },
                { id: 'only_plus', label: 'Only (+)' },
                { id: 'only_minus_minus', label: 'Only (- & -1)' },
                { id: 'only_minus_plus', label: 'Only (- & +1)' },
                { id: 'only_plus_minus', label: 'Only (+ & -1)' },
                { id: 'only_plus_plus', label: 'Only (+ & +1)' }
            ];
            
            const allPredictionTypes = [
                { id: 'minus', label: '(-)', calculateBase: (n1, n2) => [Math.abs(n2 - n1)] },
                { id: 'plus', label: '(+)', calculateBase: (n1, n2) => [n1 + n2] },
                { id: 'minus_minus', label: '(- & -1)', calculateBase: (n1, n2) => [Math.abs(n2 - n1), Math.abs(n2 - n1) - 1] },
                { id: 'minus_plus', label: '(- & +1)', calculateBase: (n1, n2) => [Math.abs(n2 - n1), Math.abs(n2 - n1) + 1] },
                { id: 'plus_minus', label: '(+ & -1)', calculateBase: (n1, n2) => [n1 + n2, n1 + n2 - 1] },
                { id: 'plus_plus', label: '(+ & +1)', calculateBase: (n1, n2) => [n1 + n2, n1 + n2 + 1] }
            ];

            const rouletteWheel = [0, 26, 3, 35, 12, 28, 7, 29, 18, 22, 9, 31, 14, 20, 1, 33, 16, 24, 5, 10, 23, 8, 30, 11, 36, 13, 27, 6, 34, 17, 25, 2, 21, 4, 19, 15, 32];
            
            function initializeState() {
                calculationState = {};
                rulePerformance = {};
                allPredictionTypes.forEach(type => {
                    calculationState[type.id] = { streak: 0, lastDistance: null, hitCount: 0, missCount: 0 };
                });
                recommendationRules.forEach(rule => {
                    rulePerformance[rule.id] = { hit: 0, total: 0 };
                });
            }

            function saveState() {
                localStorage.setItem('predictionSystemState_v2', JSON.stringify({
                    history,
                    confirmedWinsLog,
                    calculationState,
                    rulePerformance,
                    useGuideBookRules
                }));
            }

            function loadState() {
                const saved = localStorage.getItem('predictionSystemState_v2');
                if (saved) {
                    const state = JSON.parse(saved);
                    history = state.history || [];
                    confirmedWinsLog = state.confirmedWinsLog || [];
                    calculationState = state.calculationState || {};
                    rulePerformance = state.rulePerformance || {};
                    useGuideBookRules = state.useGuideBookRules !== undefined ? state.useGuideBookRules : true;
                } else {
                    initializeState();
                }
                dom.modeToggle.checked = useGuideBookRules;
                renderHistory();
            }

            function getNeighbours(number, count) {
                if (number === null || number < 0 || number > 36) return [];
                const index = rouletteWheel.indexOf(number);
                if (index === -1) return [];
                const neighbours = new Set();
                const wheelSize = rouletteWheel.length;
                for (let i = 1; i <= count; i++) {
                    neighbours.add(rouletteWheel[(index - i + wheelSize) % wheelSize]);
                    neighbours.add(rouletteWheel[(index + i) % wheelSize]);
                }
                return Array.from(neighbours);
            }
            
            function calculatePocketDistance(num1, num2) {
                const index1 = rouletteWheel.indexOf(num1);
                const index2 = rouletteWheel.indexOf(num2);
                if (index1 === -1 || index2 === -1) return Infinity;
                const directDistance = Math.abs(index1 - index2);
                return Math.min(directDistance, rouletteWheel.length - directDistance);
            }

            function formatPrediction(baseNum) {
                if (baseNum === null) return "N/A";
                let neighbors = 0;
                if (baseNum >= 0 && baseNum <= 6) neighbors = 3;
                if (baseNum >= 7 && baseNum <= 12) neighbors = 5;
                if (baseNum >= 13 && baseNum <= 18) neighbors = 4;
                if (baseNum >= 19 && baseNum <= 24) neighbors = 2;
                if (baseNum >= 25 && baseNum <= 36) neighbors = 1;
                return { text: `${baseNum}n${neighbors}`, number: baseNum, neighbors };
            }

            // --- Recommendation Engine: Guide Book Rules ---
            function getGuideBookRecommendation(predictions) {
                let bestRuleId = null;
                let highestHitRate = -1;

                recommendationRules.forEach(rule => {
                    const perf = rulePerformance[rule.id] || { hit: 0, total: 0 };
                    const hitRate = perf.total > 0 ? (perf.hit / perf.total) : -1; // Use -1 to prioritize rules with some history
                    if (hitRate > highestHitRate) {
                        highestHitRate = hitRate;
                        bestRuleId = rule.id;
                    }
                });
                
                if (!bestRuleId) bestRuleId = 'lowest_dist_highest_streak';

                let candidates = [...predictions].filter(p => p.distance !== null);
                if(candidates.length === 0) candidates = [...predictions]; // Fallback if no distances are set
                
                let recommendedPredictionId = null;

                switch(bestRuleId) {
                    case 'lowest_dist_highest_streak':
                        candidates.sort((a, b) => a.distance - b.distance || b.confirmedBy - a.confirmedBy);
                        break;
                    case 'highest_dist_highest_streak':
                        candidates.sort((a, b) => b.distance - a.distance || b.confirmedBy - a.confirmedBy);
                        break;
                    case 'lowest_dist_only':
                        candidates.sort((a, b) => a.distance - b.distance);
                        break;
                    case 'highest_dist_only':
                        candidates.sort((a, b) => b.distance - b.distance);
                        break;
                    default: // 'only_...' rules
                        const typeId = bestRuleId.replace('only_', '');
                        const filtered = candidates.filter(p => p.id === typeId);
                        if (filtered.length > 0) candidates = filtered;
                        break;
                }
                
                if (candidates.length > 0) recommendedPredictionId = candidates[0].id;
                
                return { ruleId: bestRuleId, predictionId: recommendedPredictionId, hitRate: highestHitRate < 0 ? 0 : highestHitRate };
            }
            
            // --- Recommendation Engine: Points System ---
            function getPointsSystemRecommendation(predictions) {
                let candidates = predictions.map(p => {
                    let score = 0;
                    // Hit Rate Points
                    const perf = calculationState[p.id];
                    const totalPlays = (perf.hitCount || 0) + (perf.missCount || 0);
                    const hitRate = totalPlays > 0 ? (perf.hitCount / totalPlays) * 100 : 0;
                    score += Math.max(0, hitRate - 40) * 0.5;
                    // Streak Points
                    score += Math.min(15, p.confirmedBy * 5);
                    // Distance Points
                    if (p.distance !== null && p.distance <= 5) {
                        score += (5 - p.distance) * 2;
                    }
                    return { ...p, score };
                });

                candidates.sort((a, b) => b.score - a.score);

                const bestCandidate = candidates[0];
                let signal = "Wait (Low Score)";
                if (bestCandidate.score > 25) signal = "Strong Play";
                else if (bestCandidate.score > 10) signal = "Play";
                
                return {
                    predictionId: bestCandidate.id,
                    ruleId: 'points_system',
                    ruleLabel: signal,
                    hitRate: bestCandidate.score // Using score as a proxy for confidence
                };
            }

            function displayResult(num1, num2, calcId) {
                const predictions = allPredictionTypes.map(type => {
                    const baseNumbers = type.calculateBase(num1, num2).map(n => n < 0 || n > 36 ? null : n);
                    const formatted = baseNumbers.map(formatPrediction);
                    const state = calculationState[type.id] || { streak: 0, lastDistance: null };
                    return {
                        id: type.id,
                        label: `Playing ${type.label}`,
                        predictions: formatted,
                        confirmedBy: state.streak,
                        distance: state.lastDistance,
                        hitCount: state.hitCount || 0,
                        missCount: state.missCount || 0
                    };
                });

                const recommendation = useGuideBookRules ? getGuideBookRecommendation(predictions) : getPointsSystemRecommendation(predictions);

                let html = '';
                predictions.forEach(p => {
                    const isRecommended = p.id === recommendation.predictionId;
                    let reco_badge_html = '';
                    if(isRecommended){
                        const ruleLabel = useGuideBookRules ? recommendationRules.find(r => r.id === recommendation.ruleId).label : recommendation.ruleLabel;
                        const conf = useGuideBookRules ? `${(recommendation.hitRate * 100).toFixed(0)}%` : `Score: ${recommendation.hitRate.toFixed(1)}`;
                        reco_badge_html = `<span class="recommendation-badge">RECOMMENDED (Rule: ${ruleLabel} - ${conf})</span>`;
                    }
                    
                    html += `
                        <div class="prediction-block ${isRecommended ? 'recommended' : ''}">
                            <p class="font-bold text-gray-800">${p.label}${reco_badge_html}</p>
                            <p>Prediction: <span class="font-semibold">${p.predictions.map(pred => pred.text).join(', ')}</span></p>
                            <p>Confirmed by: <span class="font-semibold">${p.confirmedBy} spin(s)</span></p>
                            <p>Distance: <span class="font-semibold">${p.distance !== null ? p.distance : 'N/A'}</span></p>
                        </div>
                    `;
                });

                html += `
                    <div class="flex items-center space-x-2 pt-4">
                        <input type="number" id="winningNumber" placeholder="Winning #" class="form-input flex-grow">
                        <button id="confirmWinBtn" class="btn btn-primary px-4">Confirm</button>
                    </div>`;

                dom.resultDisplay.innerHTML = html;
                dom.resultDisplay.classList.remove('hidden');

                document.getElementById('confirmWinBtn').addEventListener('click', () => handleConfirm(calcId, num1, num2, recommendation));
                document.getElementById('winningNumber').addEventListener('keydown', e => { if (e.key === 'Enter') handleConfirm(calcId, num1, num2, recommendation); });
            }
            
            function handleCalculation() {
                const num1 = parseInt(dom.number1.value, 10);
                const num2 = parseInt(dom.number2.value, 10);

                if (isNaN(num1) || isNaN(num2) || num1 < 0 || num1 > 36 || num2 < 0 || num2 > 36) {
                    dom.resultDisplay.innerHTML = `<div class="text-center text-red-500 font-semibold">Please enter valid numbers (0-36).</div>`;
                    dom.resultDisplay.classList.remove('hidden');
                    return;
                }
                
                const calcId = Date.now();
                history.push({ id: calcId, status: 'pending', num1, num2 });
                displayResult(num1, num2, calcId);
            }

            function handleConfirm(calcId, num1, num2, recommendation) {
                const winningNumber = parseInt(document.getElementById('winningNumber').value, 10);
                 if (isNaN(winningNumber) || winningNumber < 0 || winningNumber > 36) {
                    alert("Please enter a valid winning number (0-36).");
                    return;
                }

                const recommendedPredictionType = allPredictionTypes.find(t => t.id === recommendation.predictionId);
                let recommendationHit = false;

                allPredictionTypes.forEach(type => {
                    const baseNumbers = type.calculateBase(num1, num2).map(n => n < 0 || n > 36 ? null : n);
                    const predictions = baseNumbers.map(formatPrediction);
                    let hit = false;
                    let minDistance = Infinity;

                    predictions.forEach(p => {
                        if (p.number === null) return;
                        const hitZone = [p.number, ...getNeighbours(p.number, p.neighbors)];
                        if (hitZone.includes(winningNumber)) hit = true;
                        const dist = calculatePocketDistance(p.number, winningNumber);
                        if (dist < minDistance) minDistance = dist;
                    });
                    
                    if (hit) {
                        calculationState[type.id].streak++;
                        calculationState[type.id].hitCount++;
                    } else {
                        calculationState[type.id].streak = 0;
                        calculationState[type.id].missCount++;
                    }
                    calculationState[type.id].lastDistance = minDistance;
                });
                
                if (recommendedPredictionType) {
                    const baseNumbers = recommendedPredictionType.calculateBase(num1, num2).map(n => n < 0 || n > 36 ? null : n);
                    const predictions = baseNumbers.map(formatPrediction);
                    predictions.forEach(p => {
                        if(p.number === null) return;
                        const hitZone = [p.number, ...getNeighbours(p.number, p.neighbors)];
                        if (hitZone.includes(winningNumber)) recommendationHit = true;
                    });
                }
                
                if (useGuideBookRules && recommendation.ruleId) {
                    rulePerformance[recommendation.ruleId].total++;
                    if (recommendationHit) rulePerformance[recommendation.ruleId].hit++;
                }
                
                const historyItem = history.find(h => h.id === calcId);
                if (historyItem) {
                    historyItem.status = 'complete';
                    historyItem.winningNumber = winningNumber;
                    historyItem.recommendation = recommendation;
                    historyItem.recommendationHit = recommendationHit;
                }

                confirmedWinsLog.push(winningNumber);

                renderHistory();
                saveState();
                
                if (confirmedWinsLog.length >= 2) {
                    dom.number1.value = confirmedWinsLog[confirmedWinsLog.length - 2];
                    dom.number2.value = confirmedWinsLog[confirmedWinsLog.length - 1];
                    setTimeout(handleCalculation, 100);
                } else {
                     dom.resultDisplay.classList.add('hidden');
                }
            }
            
            function renderHistory() {
                dom.historyList.innerHTML = '';
                if (history.length === 0) {
                     dom.historyList.innerHTML = `<li class="text-center text-gray-500 py-4">No history yet.</li>`;
                }

                let totalWins = 0;
                let totalLosses = 0;

                history.slice().reverse().forEach(item => {
                    if (item.status !== 'complete') return;
                    
                    if (item.recommendationHit) totalWins++;
                    else totalLosses++;

                    const li = document.createElement('li');
                    li.className = `history-item ${item.recommendationHit ? 'is-success' : 'is-fail'}`;
                    
                    let ruleLabel = 'N/A';
                    if (item.recommendation.ruleId === 'points_system') {
                        ruleLabel = `Points System (${item.recommendation.ruleLabel})`;
                    } else if (item.recommendation.ruleId) {
                        ruleLabel = recommendationRules.find(r => r.id === item.recommendation.ruleId)?.label || 'N/A';
                    }
                    
                    li.innerHTML = `
                        <div class="flex-grow">
                            <p class="text-sm font-semibold">${item.num2} - ${item.num1} → Win: ${item.winningNumber}</p>
                            <p class="text-xs text-gray-500">Reco: ${item.recommendation.predictionId} (Rule: ${ruleLabel})</p>
                        </div>
                        <div class="font-bold text-sm ${item.recommendationHit ? 'text-green-600' : 'text-red-600'}">
                            ${item.recommendationHit ? 'HIT' : 'MISS'}
                        </div>
                    `;
                    dom.historyList.appendChild(li);
                });
                
                const total = totalWins + totalLosses;
                const rate = total > 0 ? (totalWins / total * 100).toFixed(1) + '%' : 'N/A';
                dom.winLossTracker.textContent = `Wins: ${totalWins}, Losses: ${totalLosses}, Rate: ${rate}`;
            }

            function handleClearHistory() {
                if (confirm('Are you sure you want to clear all history and learning?')) {
                    history = [];
                    confirmedWinsLog = [];
                    initializeState();
                    saveState();
                    renderHistory();
                }
            }

            // Event Listeners
            dom.calculateButton.addEventListener('click', handleCalculation);
            dom.clearHistoryButton.addEventListener('click', handleClearHistory);
            dom.swapButton.addEventListener('click', () => {
                const temp = dom.number1.value;
                dom.number1.value = dom.number2.value;
                dom.number2.value = temp;
            });
            dom.modeToggle.addEventListener('change', (e) => {
                useGuideBookRules = e.target.checked;
                saveState();
                // Optionally, recalculate the current prediction display when toggled
                if (!dom.resultDisplay.classList.contains('hidden')) {
                    handleCalculation();
                }
            });

            // Initial Load
            loadState();
        });
    </script>
</body>
</html>
